import os
import paramiko
import glob
import re
from collections import Counter
import fnmatch
import pandas as pd
from collections import defaultdict

'''
The file hierarchy looks like:
    
    ./HorseGeneAnnotation/
        private/
            sequence/
                RNASEQ/
		    bam/
		        {NCBI_GCF,ENSEMBL_GCA}/
		            {single_end,paired_end}/
        public/
	    refgen/
	        {NCBI_GCF,ENSEMBL_GCA}/
		    STAR_INDICES/
       	            	{single_end,paired_end}/
	                    GFF/
		                Merged/

'''

from snakemake.remote.S3 import RemoteProvider as S3RemoteProvider
s3_key_id = os.environ.get('AWS_ACCESS_KEY')
s3_access_key = os.environ.get('AWS_SECRET_KEY')

S3 = S3RemoteProvider(
    endpoint_url='https://s3.msi.umn.edu', 
    access_key_id=s3_key_id, 
    secret_access_key=s3_access_key
)

configfile: 'config.yaml' 

from snakemake.remote.SFTP import RemoteProvider as SFTPRemoteProvider
key = paramiko.agent.Agent().get_keys()[0]

#SFTP = SFTPRemoteProvider('login.msi.umn.edu',username='cull0084',private_key='/project/cull0084/.ssh/id_rsa')
SFTP = SFTPRemoteProvider(username='cull0084',private_key=key)

#se_samples_tmp = []
#for path in [x for x in S3._s3c.list_keys('HorseGeneAnnotation') if 'fastq' in x]: 
#    dir_path, se_file = os.path.split(path)
#    se_file = re.search(r'^(.*?)(_R[1-2]_)',se_file).group(1)
#    se_samples_tmp.append(se_file)
#    
#SE_SAMPLES = [k for k, v in Counter(se_samples_tmp).items() if v == 1]


#SUBSET = ['1M', '12F', '17M', '20M', '35F', '35M', '36F', '37M', '39F', '39M', 
#          '40M', '49M', '51F', '52M', '61M', '65F', '65M', '66F', '66M', '67F', 
#          '67M', '69F', '82M', '86M', '87M', '90M']
SUBSET = ['12F', '17M', '1M', '20M', '35F']

hiseq = True

if hiseq:
    #hiseq
    project_path = 'login.msi.umn.edu/panfs/roc/data_release/3/umgc/pre2018/2015-q4/mccuem/hiseq/151006_D00635_0082_BC7HAHANXX/Project_McCue_Project_022'
    ALL_SAMPLES, = SFTP.glob_wildcards(f'{os.path.join(project_path, "{sample}_R2_001.fastq")}')
    zipped = ''
    SAMPLES = [i for i in ALL_SAMPLES for j in SUBSET if j == i.split('_')[0]]
    print(project_path)
    print(SAMPLES)
else:
    #novaseq
    project_path = 'login.msi.umn.edu//panfs/roc/data_release/3/umgc/mccuem/novaseq/181112_A00223_0050_AHCWF7DSXX/McCue_Project_032'
    ALL_SAMPLES, = SFTP.glob_wildcards(f'{os.path.join(project_path, "{sample}_R2_001.fastq.gz")}')
    zipped = '.gz'
    SAMPLES = []
    for i in SUBSET:
        i = i[:-1] + '_' + i[-1]
        for j in ALL_SAMPLES:
            if i in j:
                SAMPLES.append(j)
    print(SAMPLES)


#REF_GFF = [f"{config['NCBI_GCF']}", f"{config['ENSEMBL_GCA']}"]
REF_GFF = [f"{config['NCBI_GCF']}"]
#REF_GFF = [f"{config['ENSEMBL_GCA']}"]

rule all:
    input:
        'merge.txt'
#        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/Merged/{sample}/{sample}.gff',sample=SAMPLES,GCF=REF_GFF),
#        f"HorseGeneAnnotation/public/refgen/{config['NCBI_GCF']}/paired_end/GFF/Merged/transcript_fpkm.tsv",
#        f"HorseGeneAnnotation/public/refgen/{config['NCBI_GCF']}/paired_end/GFF/Merged/gene_fpkm.tsv"
##        expand('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_Aligned.out.bam',GCF=REF_GFF,sample=SAMPLES)
##        expand('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}.sorted.bam',GCF=REF_GFF,sample=SAMPLES)
##        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/{sample}.gff',GCF=REF_GFF,sample=SAMPLES)
##        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/Merged.gff',GCF=REF_GFF),
##       expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/Merged/{sample}/{sample}.gff',sample=SAMPLES,GCF=REF_GFF)
#        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/Merged/transcript_fpkm.tsv',GCF=REF_GFF),
#        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/GFF/Merged/gene_fpkm.tsv',GCF=REF_GFF),
#        expand('HorseGeneAnnotation/public/refgen/{GCF}/paired_end/SalmonQuant/novaseq_TPM.tsv',GCF=REF_GFF)

# ----------------------------------------------------------
#       Trimming
# ----------------------------------------------------------

rule pe_trim_reads:
    input:
        #R1 = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}_R1_001.fastq.gz'),
        #R2 = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}_R2_001.fastq.gz')
        R1 = SFTP.remote(f'{project_path}/{{sample}}_R1_001.fastq{zipped}'),
        R2 = SFTP.remote(f'{project_path}/{{sample}}_R2_001.fastq{zipped}')
    output:
        R1 = 'HorseGeneAnnotation/private/sequence/trimmed/{sample}_trim1.fastq.gz',
        R2 = 'HorseGeneAnnotation/private/sequence/trimmed/{sample}_trim2.fastq.gz'

    message:
        'AdapterRemoval - removing adapters and low quality bases on {wildcards.sample}'
    shell:
        '''
        AdapterRemoval \
        --file1 {input.R1} \
        --file2 {input.R2} \
        --output1 {output.R1} \
        --output2 {output.R2} \
        --gzip \
        --trimns \
        --trimqualities \
        '''

#rule get_se_fastqs:
#    input:
#        S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}_R1_001.fastq.gz')
#    output:
#        'local/HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}_R1_001.fastq.gz'
#    run:
#        shell('cp {input[0]} {output[0]}')


#rule se_trim_read:
#    input:
#        #R1 = '/scratch/single_end_mapping/se_fastq/{sample}_R1_001.fastq.gz' 
#        R1 = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}_R1_001.fastq.gz',keep_local=True)
#    output:
#        #R1 = '/scratch/single_end_mapping/trimmed_data/{sample}_se_trim.fastq.gz'
#        R1 = temp('se_trimmed_data/{sample}_trim1.fastq.gz')
#    message:
#        'AdapterRemoval - removing adapters and low quality bases on SE reads {wildcards.sample}'
#    shell:
#        '''
#        AdapterRemoval \
#        --file1 {input.R1} \
#        --output1 {output.R1} \
#        --gzip \
#        --trimns \
#        --trimqualities \
#        --minquality 10 \
#        '''

# ----------------------------------------------------------
#       QC
# ----------------------------------------------------------

#rule qc_trim:
#    input:
#        S3.remote('trimmed_data/{sample}.fastq.gz')
#    params:
#        out_dir = S3.remote('qc/qc_trim')
#    output:
#        S3.remote('qc/qc_trim/{sample}_fastqc.html')
#    message:
#        'FastQC - performing quality control on trimmed {wildcards.sample}'
#    shell:
#        '''
#        fastqc \
#        -o {params.out_dir} \
#        -f fastq \
#        {input}
#        '''
#
#rule qc_raw:
#    input:
#        S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/fastq/{sample}.fastq.gz')
#    params:
#        out_dir = S3.remote('qc/qc_raw')
#    output:
#        S3.remote('qc/qc_raw/{sample}_fastqc.html')
#    message:
#        'FastQC - performing quality control on {wildcards.sample}'
#    shell:
#        '''
#        fastqc \
#        -o {params.out_dir} \
#        -f fastq \
#        {input}
#        '''

# ----------------------------------------------------------
#       STAR indices
# ----------------------------------------------------------

rule download_STAR:
    input:
        expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/download.done',GCF=config['NCBI_GCF']),
        expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/download.done',GCA=config['ENSEMBL_GCA'])

#DOES NOT STORE UNMAPPED READS (--outReadsUnmapped) nor log output
rule ncbi_STAR_index:
    input:
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/Genome',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/SA',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/SAindex',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/chrLength.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/chrName.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/chrNameLength.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/chrStart.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/exonGeTrInfo.tab',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/exonInfo.tab',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/geneInfo.tab',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/genomeParameters.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/sjdbInfo.txt',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/sjdbList.fromGTF.out.tab',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/sjdbList.out.tab',GCF=config['NCBI_GCF']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/transcriptInfo.tab',GCF=config['NCBI_GCF']),keep_local=True) 
    output:
        touch(expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/download.done',GCF=config['NCBI_GCF']))


rule ensembl_STAR_index:
    input:
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/Genome',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/SA',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/SAindex',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/chrLength.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/chrName.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/chrNameLength.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/chrStart.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/exonGeTrInfo.tab',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/exonInfo.tab',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/geneInfo.tab',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/genomeParameters.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/sjdbInfo.txt',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/sjdbList.fromGTF.out.tab',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/sjdbList.out.tab',GCA=config['ENSEMBL_GCA']),keep_local=True),
        S3.remote(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/transcriptInfo.tab',GCA=config['ENSEMBL_GCA']),keep_local=True) 
    output:
        touch(expand('HorseGeneAnnotation/public/refgen/{GCA}/STAR_INDICES/download.done',GCA=config['ENSEMBL_GCA']))

# ----------------------------------------------------------
#       STAR mapping
# ----------------------------------------------------------

rule pe_STAR_mapping:
    input:
        R1 = 'HorseGeneAnnotation/private/sequence/trimmed/{sample}_trim1.fastq.gz',
        R2 = 'HorseGeneAnnotation/private/sequence/trimmed/{sample}_trim2.fastq.gz',
        star_dl = 'HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/download.done'
    output:
        S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_Aligned.out.bam')
    params:
        out_prefix = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_'),
        star_index = 'HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES'
    message:
        'STAR - Creating: {output} '
    run:
        assert os.path.exists(input.star_dl)
        shell('''
        STAR \
        --genomeDir {params.star_index} \
        --genomeLoad LoadAndKeep \
        --readFilesIn {input.R1} {input.R2} \
        --readFilesCommand gunzip -c \
        --outFileNamePrefix {params.out_prefix} \
        --outSAMtype BAM Unsorted \
        ''')


##rule pe_STAR_mapping:
##    input:
##        R1 = 'pe_trimmed_data/{sample}_trim1.fastq.gz',
##        R2 = 'pe_trimmed_data/{sample}_trim2.fastq.gz',
##        star_index = expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES/download.done',GCF=config['NCBI_GCF'])
##    output:
##        S3.remote(expand('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_Aligned.out.bam',sample=SAMPLES,GCF=config['NCBI_GCF']),keep_local=True)
##    params:
##        out_prefix = S3.remote(expand('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_',sample=SAMPLES,GCF=config['NCBI_GCF']),keep_local=True),
##        star_index = expand('HorseGeneAnnotation/public/refgen/{GCF}/STAR_INDICES',GCF=config['NCBI_GCF'])
##    message:
##        'STAR - Creating: {output} '
##    run:
##        assert os.path.exists(input.star_index)
##        shell('''
##        STAR \
##        --genomeDir {params.star_index} \
##        --genomeLoad LoadAndKeep \
##        --readFilesIn {input.R1} {input.R2} \
##        --readFilesCommand gunzip -c \
##        --outFileNamePrefix {params.out_prefix} \
##        --outSAMtype BAM Unsorted \
##        ''')
#
##rule se_STAR_mapping:
##    input:
##        R1 = '/scratch/single_end_mapping/trimmed_data/{sample}_se_trim.fastq.gz',
##        #star_index = '/scratch/HorseGeneAnnotation/public/refgen/GCF_002863925.1_EquCab3.0/STAR_INDICES/download.done'
##    params:
##        out_prefix = '/scratch/single_end_mapping/star_map_se/RNASEQ/bam/{sample}_se_',
##        star_index = '/scratch/RNAMapping/HorseGeneAnnotation/public/refgen/GCF_002863925.1_EquCab3.0/STAR_INDICES'
##    output:
##        '/scratch/single_end_mapping/star_map_se/RNASEQ/bam/{sample}_se_Aligned.out.bam'
##    message:
##        'STAR - Creating: {output} '
##    run:
##        #assert os.path.exists(params.star_index)
##        shell('''
##        STAR \
##        --genomeDir {params.star_index} \
##        --genomeLoad LoadAndKeep \
##        --readFilesIn {input.R1} \
##        --readFilesCommand gunzip -c \
##        --outFileNamePrefix {params.out_prefix} \
##        --outSAMtype BAM Unsorted \
##        ''')

# ----------------------------------------------------------
#       Sort BAMs
# ----------------------------------------------------------

rule pe_sort_bam:
    input:
        bam = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}_Aligned.out.bam')
    output:
        sortedbam = S3.remote('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}.sorted.bam')
    shell:
        '''
        samtools view -u {input.bam} | samtools sort - -o {output.sortedbam}
        '''

# ----------------------------------------------------------
#       Merge BAMs
# ----------------------------------------------------------

rule compose_merge:
    input:
        bams = S3.remote(expand('HorseGeneAnnotation/private/sequence/RNASEQ/bam/{GCF}/paired_end/{sample}.sorted.bam', sample=SAMPLES, GCF=REF_GFF))
    output:
        txt = 'merge.txt'
    run:
#        with open(output.txt, 'w') as out:
#            print(*input, sep="\n", file=out)
        d = defaultdict(list)
        for i in input.bams:
            i = os.path.basename(i.split('_')[0])
            for j in input.bams:
                if i == os.path.basename(j.split('_')[0]):
                    if len(d[i]) < 2:
                        d[i].append(j)
        cmds = [f'samtools merge {v[0]}_{v[1][-4:]}.sorted.bam {v[0]} {v[1]}' 
                for v in d.values() 
                if len(v) > 1]
        print(cmds)
        with open(output.txt, 'w') as out:
            for v in d.values():
                if len(v) > 1:
                    print(f'{v[0]}_{v[1][-4:]}.sorted.bam', file=out)
                else:
                    print(v+'.sorted.bam', file=out) 


##rule se_sort_bam:
##    input:
##        bam = '/scratch/single_end_mapping/star_map_se/RNASEQ/bam/{sample}_se_Aligned.out.bam'
##    output:
##        sorted_bam = '/scratch/single_end_mapping/star_map_se/RNASEQ/bam/{sample}_se.sorted.bam'
##    shell:
##        '''
##        samtools view -u {input.bam} | samtools sort -o {output.sorted_bam}
##        '''

